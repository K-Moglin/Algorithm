# 不定长滑动窗口

三类：求最长子数组    求最短子数组  求子数组个数

## 越短越合法/求最长/最大

题目套路：求最长子串，通过一些限制条件使得子串越短越符合条件如：“不重复”“某元素个数不超过”等，经常结合hashmap或者set来完成

典型题目：

* [3.无重复字符的最长字串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)
* [3090.每个字符最多出现两次的最长字符串](https://leetcode.cn/problems/maximum-length-substring-with-two-occurrences/description/)

伪代码模板：

```cpp
{
	int n = array.size();
	int ans = 0;
	int left = 0;
	for (int right = 0; right < n; right++) {
		//窗口右侧开始向右扩展
		if (array[right]满足什么条件) {
			unordered_map来记录
		}

		//字串已经不满足条件开始收缩左侧
		while (字串满足什么条件) {   //当此时的字串一般达到一定长度但是开始不满足题目条件，所以开始收缩左侧
			if(array[left]满足什么条件) {
				进行修改；
			}
			left++；
		}

		//记录符合条件的最长字串
		ans = max(ans, right - left + 1);
	}
	return ans;
}
```


## 越长越合法/求最短/最小

题目套路：求满足条件的长度最小子串，越长越符合条件 如：“元素和达到某个target”“替换子串...”

典型题目：

* [最小覆盖子串(hard)](https://leetcode.cn/problems/minimum-window-substring/description/)
* [最小区间(hard)](https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/description/)

note: 有时候题目会问从两头取子串，等价于去掉一个中间的子串。此时我们可以通过对left和right进行取模的操作来模拟像是两个相同的数组取尾部和头部。

典型例题：[无限数组的最短子数组](https://leetcode.cn/problems/minimum-size-subarray-in-infinite-array/description/)

![无限数组](image/不定长滑动窗口/无限数组.png)
