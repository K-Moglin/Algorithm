# 不定长滑动窗口

三类：求最长子数组    求最短子数组  求子数组个数

## 越短越合法/求最长/最大

题目套路：求最长子串，通过一些限制条件使得子串越短越符合条件如：“不重复”“某元素个数不超过”等，经常结合hashmap或者set来完成

典型题目：

* [3.无重复字符的最长字串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)
* [3090.每个字符最多出现两次的最长字符串](https://leetcode.cn/problems/maximum-length-substring-with-two-occurrences/description/)

伪代码模板：

```cpp
{
	int n = array.size();
	int ans = 0;
	int left = 0;
	for (int right = 0; right < n; right++) {
		//窗口右侧开始向右扩展
		if (array[right]满足什么条件) {
			unordered_map来记录
		}

		//字串已经不满足条件开始收缩左侧
		while (字串满足什么条件) {   //当此时的字串一般达到一定长度但是开始不满足题目条件，所以开始收缩左侧
			if(array[left]满足什么条件) {
				进行修改；
			}
			left++；
		}

		//记录符合条件的最长字串
		ans = max(ans, right - left + 1);
	}
	return ans;
}
```

## 越长越合法/求最短/最小

题目套路：求满足条件的长度最小子串，越长越符合条件 如：“元素和达到某个target”“替换子串...”

典型题目：

* [最小覆盖子串(hard)](https://leetcode.cn/problems/minimum-window-substring/description/)
* [最小区间(hard)](https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/description/)

note: 有时候题目会问从两头取子串，等价于去掉一个中间的子串。此时我们可以通过对left和right进行取模的操作来模拟像是两个相同的数组取尾部和头部。

典型例题：[无限数组的最短子数组](https://leetcode.cn/problems/minimum-size-subarray-in-infinite-array/description/)

![无限数组](image/不定长滑动窗口/无限数组.png)

## 求子数组个数

求子数组个数的关键点在于个数的求法，不同情况有差异

### 越短越合法

一般要写 `ans += right - left + 1`

即内层循环结束的标志是右端点固定情况下左端点到右端点最长合法

内层循环结束后，[left,right] 这个子数组是满足题目要求的。由于子数组越短，越能满足题目要求，所以除了 [left,right]，还有 [left+1,right],[left+2,right],…,[right,right] 都是满足要求的。也就是说，当右端点固定在 right 时，左端点在 left,left+1,left+2,…,right 的所有子数组都是满足要求的，这一共有 right−left+1 个。

典型题目：

* [713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/description/)
* [2302. 统计得分小于 K 的子数组数目](https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/description/)

### 越长越合法

一般要写 `ans += left`

内层循环结束后，[left,right] 这个子数组是不满足题目要求的，但在退出循环之前的最后一轮循环，[left−1,right] 是满足题目要求的。由于子数组越长，越能满足题目要求，所以除了 [left−1,right]，还有 [left−2,right],[left−3,right],…,[0,right] 都是满足要求的。也就是说，当右端点固定在 right 时，左端点在 0,1,2,…,left−1 的所有子数组都是满足要求的，这一共有 left 个。

我们关注的是 left−1 的合法性，而不是 left。

典型题目：

* [2799. 统计完全子数组的数目](https://leetcode.cn/problems/count-complete-subarrays-in-an-array/description/)
* [3298. 统计重新排列后包含另一个字符串的子字符串数目 II(hard)](https://leetcode.cn/problems/count-substrings-that-can-be-rearranged-to-contain-a-string-ii/description/)

### 恰好型滑动窗口

例如，要计算有多少个元素和恰好等于 k 的子数组，可以把问题变成：

计算有多少个元素和 ≥k 的子数组。
计算有多少个元素和 >k，也就是 ≥k+1 的子数组。
答案就是元素和 ≥k 的子数组个数，减去元素和 ≥k+1 的子数组个数。这里把 > 转换成 ≥，从而可以把滑窗逻辑封装成一个函数 solve，然后用 solve(k)−solve(k+1) 计算，无需编写两份滑窗代码。

解释：如果有10个数>=3其中有4个数>=4那恰好=3的数就是10 - 4 = 6个

总结：「恰好」可以拆分成两个「至少」，也就是两个「越长越合法」的滑窗问题。

注：也可以把问题变成 ≤k 减去 ≤k−1，即两个「至多」。可根据题目选择合适的变形方式。

注：也可以把两个滑动窗口合并起来，维护同一个右端点 right 和两个左端点 left1和 left2，我把这种写法叫做三指针滑动窗口。

典型题目：

* [3306. 元音辅音字符串计数 II](https://leetcode.cn/problems/count-of-substrings-containing-every-vowel-and-k-consonants-ii/description/)
* [992. K 个不同整数的子数组(hard))](https://leetcode.cn/problems/subarrays-with-k-different-integers/description/)

```cpp
//在c++代码中我们通常可以把越长越合法的滑动窗口在这里用匿名函数写在主方法里面
{
	auto f = [&](int k) -> int {
		//变量
		for(int right = 0； right < array.size(); right++) {
			//右端点进入

			while(符合条件) {
				//左端点出
			}

			ans += left;
		}
		return ans;
	};
	return f(k) - f(k + 1);
}
```
